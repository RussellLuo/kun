package oasv2

import (
	"fmt"
	"strings"

	"github.com/RussellLuo/kok/gen/util/generator"
	"github.com/RussellLuo/kok/gen/util/misc"
	"github.com/RussellLuo/kok/gen/util/openapi"
	"github.com/RussellLuo/kok/gen/util/reflector"
)

var (
	template = `// Code generated by kok; DO NOT EDIT.
// github.com/RussellLuo/kok

package {{.Result.PkgName}}

import (
	"bufio"
	"bytes"
	"fmt"
	"net/http"
	"net/http/httptest"
	"reflect"
	"strings"
	"text/template"

	chimiddleware "github.com/go-chi/chi/middleware"
	httpcodec "github.com/RussellLuo/kok/pkg/codec/httpv2"
	"github.com/RussellLuo/kok/pkg/oasv2"
)

var (
	base = ` + "`" + `swagger: "2.0"
info:
  version: "1.0.0"
  title: "Swagger Example"
  description: ""
  license:
    name: "MIT"
host: "example.com"
basePath: "/api"
schemes:
  - "https"
consumes:
  - "application/json"
produces:
  - "application/json"
` + "`" + `

{{- $operationsGroupByPattern := operationsGroupByPattern .Spec.Operations}}

	paths = ` + "`" + `
paths:
{{- range $operationsGroupByPattern}}
  {{.Pattern}}:

  {{- range .Operations}}
  {{- $nonCtxParams := nonCtxParams .Request.Params}}
    {{lower .Method}}:
      description: ""
      operationId: "{{.Name}}"
      {{- $nonCtxNonBodyFlatParams := nonBodyFlatParams $nonCtxParams}}
      {{- if $nonCtxParams}}
      parameters:
        {{- range $nonCtxNonBodyFlatParams}}
        - name: {{.Alias}}
          in: {{.In}}
          required: {{.Required}}
          {{paramSchema .Type}}
          description: ""
        {{- end}} {{/* range $nonCtxNonBodyFlatParams */}}

        {{- $bodyParams := bodyParams $nonCtxParams}}
        {{- if $bodyParams}}
        - name: body
          in: body
          schema:
            $ref: "#/definitions/{{.Name}}RequestBody"
        {{- end}}
      {{- end}} {{/* if $nonCtxParams */}}
      %s
  {{- end}} {{/* range .Operations */}}

{{- end}} {{/* range $operationsGroupByPattern */}}
` + "`" + `
)

func getResponses(schema oasv2.Schema) []oasv2.OASResponses {
	return []oasv2.OASResponses{
		{{- range $operationsGroupByPattern}}
		{{- range .Operations}}
		oasv2.GetOASResponses(schema, "{{.Name}}", {{.SuccessResponse.StatusCode}}, {{addAmpersand .Name}}Response{}),
		{{- end}} {{/* range .Operations */}}
		{{- end}} {{/* range $operationsGroupByPattern */}}
	}
}

func getDefinitions(schema oasv2.Schema) map[string]oasv2.Definition {
	defs := make(map[string]oasv2.Definition)

	{{range .Spec.Operations -}}

    {{- $nonCtxParams := nonCtxParams .Request.Params}}
    {{- $bodyParams := bodyParams $nonCtxParams}}
	{{- if $bodyParams}}
	oasv2.AddDefinition(defs, "{{.Name}}RequestBody", reflect.ValueOf(&struct{
		{{- range $bodyParams}}
		{{title .Name}} {{.Type}} {{addTag .Name .Type}}
		{{- end}} {{/* range $bodyParams */}}
	}{}))
	{{- end}} {{/* if $bodyParams */}}
	oasv2.AddResponseDefinitions(defs, schema, "{{.Name}}", {{.SuccessResponse.StatusCode}}, {{addAmpersand .Name}}Response{})

    {{end -}} {{/* range .Spec.Operations */}}

	return defs
}

func OASv2APIDoc(schema oasv2.Schema) string {
	resps := getResponses(schema)
	paths := oasv2.GenPaths(resps, paths)

	defs := getDefinitions(schema)
	definitions := oasv2.GenDefinitions(defs)

	return base + paths + definitions
}
`
)

type Options struct {
	SchemaPtr         bool
	SchemaTag         string
	TagKeyToSnakeCase bool
	Formatted         bool
}

type Generator struct {
	opts *Options
}

func New(opts *Options) *Generator {
	return &Generator{opts: opts}
}

func (g *Generator) Generate(result *reflector.Result, spec *openapi.Specification) ([]byte, error) {
	data := struct {
		Result *reflector.Result
		Spec   *openapi.Specification
	}{
		Result: result,
		Spec:   spec,
	}

	type OperationsPerPattern struct {
		Pattern    string
		Operations []*openapi.Operation
	}

	return generator.Generate(template, data, generator.Options{
		Funcs: map[string]interface{}{
			"title": strings.Title,
			"lower": strings.ToLower,
			"operationsGroupByPattern": func(ops []*openapi.Operation) (outOps []*OperationsPerPattern) {
				var opp *OperationsPerPattern
				var ok bool

				patternToOps := make(map[string]*OperationsPerPattern)

				for _, op := range ops {
					opp, ok = patternToOps[op.Pattern]
					if !ok {
						opp = &OperationsPerPattern{Pattern: op.Pattern}
						outOps = append(outOps, opp)
						patternToOps[op.Pattern] = opp
					}
					opp.Operations = append(opp.Operations, op)
				}

				return
			},
			"paramSchema": func(typ string) string {
				switch typ {
				case "int", "int8", "int16", "int32", "int64",
					"uint", "uint8", "uint16", "uint32", "uint64":
					return "type: integer"
				case "float32", "float64":
					return "type: number"
				case "string":
					return "type: string"
				case "bool":
					return "type: boolean"
				default:
					return fmt.Sprintf(`$ref: "#/definitions/%s"`, typ)
				}
			},
			"nonCtxParams": func(params []*openapi.Param) (out []*openapi.Param) {
				for _, p := range params {
					if p.Type != "context.Context" && p.In != openapi.InRequest {
						// Parameters in `request` have no relationship with OAS.
						out = append(out, p)
					}
				}
				return
			},
			"nonBodyFlatParams": func(in []*openapi.Param) (out []*openapi.Param) {
				for _, p := range in {
					if p.In != openapi.InBody {
						if len(p.Sub) == 0 {
							out = append(out, p)
						} else {
							// Only one nested level is supported.
							out = append(out, p.Sub...)
						}
					}
				}
				return
			},
			"bodyParams": func(in []*openapi.Param) (out []*openapi.Param) {
				for _, p := range in {
					if p.In == openapi.InBody {
						out = append(out, p)
					}
				}
				return
			},
			"addAmpersand": func(name string) string {
				if g.opts.SchemaPtr {
					return "&" + name
				}
				return name
			},
			"addTag": func(name, typ string) string {
				if g.opts.SchemaTag == "" {
					return ""
				}

				if typ == "error" {
					name = "-"
				} else if g.opts.TagKeyToSnakeCase {
					name = misc.ToSnakeCase(name)
				}

				return fmt.Sprintf("`%s:\"%s\"`", g.opts.SchemaTag, name)
			},
		},
		Formatted: g.opts.Formatted,
	})
}
